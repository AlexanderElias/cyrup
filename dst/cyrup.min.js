
/*
    Name: cyrup
    Version: 0.7.9
    License: MPL-2.0
    Author: Alexander Elias
    Email: alex.steven.elias@gmail.com
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

class Permission{constructor(a={}){const{allows:b,denies:c,requires:d,action:e,resource:f,behavior:g}=a;if(this._edit=!0,this._action=null,this._resource=null,this._behavior=null,this._allows=[],this._denies=[],this._requires={},"action"in a&&this.action(e),"resource"in a&&this.resource(f),"behavior"in a&&this.behavior(g),"allows"in a){if(!1==b instanceof Array)throw new Error("permission allows illegal type");b.forEach(a=>this.allow(a));}if("denies"in a){if(!1==c instanceof Array)throw new Error("permission denies illegal type");c.forEach(a=>this.deny(a));}if("requires"in a){if(!1==d instanceof Object)throw new Error("permission requires illegal type");Object.entries(d).forEach(([a,b])=>this.require(a,b));}}edit(a){if(void 0===a)return this._edit;if("boolean"!=typeof a)throw new Error("permission edit boolean required");return this._edit=a,this}action(a){if(void 0===a)return this._action;if("string"!=typeof a)throw new Error("permission action string required");return this._action=a,this}resource(a){if(void 0===a)return this._resource;if("string"!=typeof a)throw new Error("permission resource string required");return this._resource=a,this}behavior(a){if(void 0===a)return this._behavior;if("boolean"!=typeof a)throw new Error("permission behavior boolean required");return this._behavior=a,this}allows(){return Object.freeze(this._allows)}allow(a){if("string"!=typeof a)throw new Error("permission allow string required");const b=this._allows.includes(a);if(b)throw new Error(`permission allow ${a} exists`);return this._allows.push(a),this}denies(){return Object.freeze(this._deniess)}deny(a){if("string"!=typeof a)throw new Error("permission deny string required");const b=this._denies.includes(a);if(b)throw new Error(`permission deny ${a} exists`);return this._denies.push(a),this}requires(){return Object.freeze(this._requires)}require(a,b){if("string"!=typeof a)throw new Error("permission name string required");if(!("boolean"!=typeof b||"number"!=typeof b||"string"!=typeof b||b instanceof Array))throw new Error("permission value string or array required");return this._requires[a]=b,this}traverse(a,b){const c=a.split("."),d=c.pop();return c.forEach(a=>b=b[a]),[d,b]}validate(a,b,c){if("object"!=typeof c)return !1;if("string"!=typeof b)return !1;if("string"!=typeof a)return !1;if(this._action!==b)return !1;if(this._resource!==a)return !1;for(const d in this._requires){const[a,b]=this.traverse(d,c),e=this._requires[a],f=b[a];if(!(a in b))return !1;else if(e instanceof Array&&e.includes(f)||e===f)continue;else return !1}if(this._behavior)for(const a of this._denies){const[b,d]=this.traverse(a,c);if(b in d)return !1;continue}else for(const a of this._allows){const[b,d]=this.traverse(a,c);if(b in d)return !1;continue}return !0}valid(){return !("string"!=typeof this._action)&&!("string"!=typeof this._resource)&&!("boolean"!=typeof this._behavior)}toJSON(){return {edit:this._edit,action:this._action,resource:this._resource,behavior:this._behavior,allows:this._allows,denies:this._denies,requires:this._requires}}}

class Role{constructor(a={}){const{name:b,active:c,permissions:d}=a;if(this._edit=!0,this._name=null,this._active=null,this._permissions=[],"name"in a&&this.name(b),"active"in a&&this.active(c),"permissions"in a){if(!1==d instanceof Array)throw new Error("role permissions illegal type");d.forEach(a=>this.permission(a));}}edit(a){if(void 0===a)return this._edit;if("boolean"!=typeof a)throw new Error("role edit boolean required");return this._edit=a,this}name(a){if(void 0===a)return this._name;if("string"!=typeof a)throw new Error("role name string required");return this._name=a,this}active(a){if(void 0===a)return this._active;if("boolean"!=typeof a)throw new Error("role active boolean required");return this._active=a,this}permissions(){return Object.freeze(this._permissions)}permission(){const a=new Permission(...arguments);return this.add(a),a}get(a,b){return this._permissions.find(c=>c.action()===b&&c.resource()===a)}add(a){if(!1==a instanceof Permission)throw new Error("role add requires permission");const b=a.action(),c=a.resource(),d=this._permissions.find(({_resource:a,_action:d})=>a===c&&d===b);if(d)throw new Error(`role add permission ${c} ${b} exists`);return this._permissions.push(a),this}validate(a,b,c){if("object"!=typeof c)return !1;if("string"!=typeof b)return !1;if("string"!=typeof a)return !1;if(!1===this._active)return !1;const d=this.get(a,b);return !!d&&d.validate(a,b,c)}valid(){if("string"!=typeof this._name)return !1;if("boolean"!=typeof this._active)return !1;for(const a of this._permissions)if(!1===a.valid())return !1;return !0}toJSON(){return {edit:this._edit,name:this._name,active:this._active,permissions:this._permissions.map(a=>a.toJSON())}}}

class Access{constructor(a={}){const{roles:b}=a;if(this._roles={},"roles"in a){if(!1==b instanceof Array)throw new Error("access roles illegal type");b.forEach(a=>this.role(a));}}role(){const a=new Role(...arguments);return this.add(a),a}get(a){if(!1==a instanceof Role)throw new Error("access get requires role");const b=a.name();return this._roles[b]}add(a){if(!1==a instanceof Role)throw new Error("access add requires role");const b=a.name(),c=b in this._roles;if(c)throw new Error(`access add role ${b} exists`);return this._roles[b]=a,this}remove(a){if(!1==a instanceof Role)throw new Error("access remove requires role");const b=a.name(),c=b in this._roles;if(c)throw new Error(`access remove role ${b} exists`);return delete this._roles[b],this}roles(){return Object.freeze(this._roles)}toJSON(){return this._roles}}

const Cyrup={ENCODING:"hex",ITERATIONS:999999,KEY:32,TAG:16,SALT:16,VECTOR:12,RANDOM:20,HASH:"sha-512",ALGORITHM:"aes-256-gcm",Role,Access,Permission,role(){return new Role(...arguments)},access(){return new Access(...arguments)},permission(){return new Permission(...arguments)},async random(a){const b=this;a=a||b.RANDOM;const c=await b.randomBytes(a),d=await b.bufferToHex(c);return d},async hash(a,b){const c=this;if(!a)throw new Error("Cyrup.hash - item argument required");b=c.normalizeHash(b||c.HASH);const d=await c.stringToBuffer(a),e=await c.createHash(d,b),f=await c.bufferToHex(e);return f},async compare(a,b){const c=this;if(!b)throw new Error("Cyrup.compare - key argument required");if(!a)throw new Error("Cyrup.compare - password argument required");const d=await c.hexToBuffer(b.split(":")[1]),e=await c.key(a,{salt:d});return e===b},async key(a,b){const c=this;if(!a)throw new Error("Cyrup.key - item argument required");b=b||{},b.size=b.size||c.KEY,b.salt=b.salt||c.SALT,b.iterations=b.iterations||c.ITERATIONS,b.hash=c.normalizeHash(b.hash||c.HASH);const[d,e]=await Promise.all(["string"==typeof a?c.stringToBuffer(a):a,"string"==typeof b.salt?c.stringToBuffer(b.salt):"number"==typeof b.salt?c.randomBytes(b.salt):b.salt]),f=await c.pbkdf2(d,e,b.iterations,b.size,b.hash),[g,h]=await Promise.all([c.bufferToHex(f),c.bufferToHex(e)]);return `${g}:${h}`},async encrypt(a,b,c,d){const e=this;if(!b)throw new Error("Cyrup.encrypt - key argument required");if(!a)throw new Error("Cyrup.encrypt - data argument required");b=b.split(":"),d=d||e.VECTOR,c=e.normalizeAlgorithm(c||e.ALGORITHM);const[f,g,h]=await Promise.all([e.hexToBuffer(b[0]),"string"==typeof a?e.stringToBuffer(a):a,"string"==typeof d?e.stringToBuffer(d):e.randomBytes(d)]),i=await e.cipher(c,f,h,g),[j,k]=await Promise.all([e.bufferToHex(i),e.bufferToHex(h)]);return `${j}:${k}`},async decrypt(a,b,c){const d=this;if(!b)throw new Error("Cyrup.decrypt - key argument required");if(!a)throw new Error("Cyrup.decrypt - data argument required");c=d.normalizeAlgorithm(c||d.ALGORITHM),b=b.split(":"),a=a.split(":");const[e,f,g]=await Promise.all([d.hexToBuffer(b[0]),d.hexToBuffer(a[0]),d.hexToBuffer(a[1])]),h=await d.decipher(c,e,g,f),i=await d.bufferToString(h);return i}};if("undefined"==typeof window){const a=require("util"),b=require("crypto"),c=a.promisify(b.pbkdf2),d=a.promisify(b.randomBytes);Cyrup.normalizeHash=function(a){return a.replace("-","").toLowerCase()},Cyrup.normalizeAlgorithm=function(a){return 0===a.toLowerCase().indexOf("aes")?a.toLowerCase():a},Cyrup.hexToBuffer=async function(a){return Buffer.from(a,"hex")},Cyrup.bufferToHex=async function(a){return a.toString("hex")},Cyrup.stringToBuffer=async function(a){return Buffer.from(a,"utf8")},Cyrup.bufferToString=async function(a){return a.toString("utf8")},Cyrup.createHash=async function(a,c){return b.createHash(c).update(a).digest()},Cyrup.randomBytes=async function(a){return d(a)},Cyrup.pbkdf2=async function(a,b,d,e,f){return c(a,b,d,e,f)},Cyrup.cipher=async function(a,c,d,e){const f=b.createCipheriv(a,c,d);return Buffer.concat([f.update(e,"utf8"),f.final(),f.getAuthTag()])},Cyrup.decipher=async function(a,c,d,e){const f=this,g=Buffer.from(e,"hex"),h=g.slice(g.byteLength-f.TAG),i=g.slice(0,g.byteLength-f.TAG),j=b.createDecipheriv(a,c,d);return j.setAuthTag(h),Buffer.concat([j.update(i),j.final()])};}else Cyrup.normalizeHash=function(a){return a.toUpperCase()},Cyrup.normalizeAlgorithm=function(a){if(0!==a.toLowerCase().indexOf("aes"))return a;const b=a.split("-");return (b[0]+"-"+b[2]).toUpperCase()},Cyrup.getAuthTag=function(a){return a.slice(a.byteLength-this.TAG)},Cyrup.hexToBuffer=async function(a){if("string"!=typeof a)throw new TypeError("Cyrup.hexToBuffer - expected input to be a string");if(0!=a.length%2)throw new RangeError("Cyrup.hexToBuffer - expected string to be an even number of characters");const b=new Uint8Array(a.length/2);for(let c=0,d=a.length;c<d;c+=2)b[c/2]=parseInt(a.substring(c,c+2),16);return b.buffer},Cyrup.bufferToHex=async function(a){const b=new Uint8Array(a),c=Array(b.length);for(let d=0,e=b.length;d<e;d++)c[d]=("00"+b[d].toString(16)).slice(-2);return c.join("")},Cyrup.stringToBuffer=async function(a){const b=new Uint8Array(a.length);for(let c=0,d=a.length;c<d;c++)b[c]=a.charCodeAt(c);return b.buffer},Cyrup.bufferToString=async function(a){var b=String.fromCharCode;const c=new Uint8Array(a),d=Array(c.length);for(let e=0,f=c.length;e<f;e++)d[e]=b(c[e]);return d.join("")},Cyrup.createHash=async function(a,b){return window.crypto.subtle.digest(b,a)},Cyrup.randomBytes=async function(a){return window.crypto.getRandomValues(new Uint8Array(a))},Cyrup.pbkdf2=async function(a,b,c,d,e){const f=await window.crypto.subtle.importKey("raw",a,{name:"PBKDF2"},!1,["deriveBits"]),g=await window.crypto.subtle.deriveBits({salt:b,iterations:c,name:"PBKDF2",hash:{name:e}},f,d<<3);return new Uint8Array(g)},Cyrup.cipher=async function(a,b,c,d){const e=this,f=await window.crypto.subtle.importKey("raw",b,{name:a},!1,["encrypt"]),g=await window.crypto.subtle.encrypt({iv:c,name:a,tagLength:8*e.TAG},f,d);return g},Cyrup.decipher=async function(a,b,c,d){const e=this,f=await window.crypto.subtle.importKey("raw",b,{name:a},!1,["decrypt"]),g=await window.crypto.subtle.decrypt({iv:c,name:a,tagLength:8*e.TAG},f,d);return g};

export default Cyrup;
