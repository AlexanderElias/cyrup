/*
	Name: cyrup
	Version: 0.0.6
	License: MPL-2.0
	Author: Alexander Elias
	Email: alex.steven.elias@gmail.com
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a};(function(a,b){"object"===("undefined"==typeof exports?"undefined":_typeof(exports))&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define("Cyrup",b):a.Cyrup=b()})(this,function(){"use strict";return{ROUNDS:99999,ENCODING:"hex",ALGORITHM:"AES-GCM",SALT_BYTES:16,HASH_BYTES:32,VECTOR_BYTES:12,SECRET_BYTES:48,HASH_TYPE:"SHA-512",randomBytes:function(a){return Promise.resolve().then(function(){return window.crypto.getRandomValues(new Uint8Array(a))})},hexToBuffer:function(a){return Promise.resolve().then(function(){if("string"!=typeof a)throw new TypeError("Expected input to be a string");if(0!=a.length%2)throw new RangeError("Expected string to be an even number of characters");for(var b=new Uint8Array(a.length/2),c=0,d=a.length;c<d;c+=2)b[c/2]=parseInt(a.substring(c,c+2),16);return b.buffer})},bufferToHex:function(a){return Promise.resolve().then(function(){for(var b=new Uint8Array(a),c=[],d=0,e=b.length;d<e;d++){var f=b[d].toString(16),g=("00"+f).slice(-2);c.push(g)}return c.join("")})},stringToBuffer:function(a){return Promise.resolve().then(function(){for(var b=new Uint8Array(a.length),c=0,d=a.length;c<d;c++)b[c]=a.charCodeAt(c);return b.buffer})},bufferToString:function(a){return Promise.resolve().then(function(){for(var b="",c=new Uint8Array(a),d=0,e=c.length;d<e;d++)b+=String.fromCharCode(c[d]);return b})},pbkdf2:function(a,b,c,d,e){var f=this;if(!b)throw new Error("salt required");if(!d)throw new Error("digest required");if(!a)throw new Error("password required");if(!c)throw new Error("iterations required");return Promise.resolve().then(function(){return window.crypto.subtle.importKey("raw",a,{name:"PBKDF2"},!1,["deriveBits","deriveKey"])}).then(function(a){return window.crypto.subtle.deriveKey({salt:b,name:"PBKDF2",hash:d||f.HASH_TYPE,iterations:c||f.ROUNDS},a,{length:256,name:e||f.ALGORITHM},!1,["encrypt","decrypt"])})},secret:function(a){var b=this;return a=a||{},a.bytes=a.bytes||b.SECRET_BYTES,a.encoding=a.encoding||b.ENCODING,Promise.resolve().then(function(){return b.randomBytes(a.bytes)}).then(function(a){return b.bufferToHex(a)})},hash:function(a,b){var c=this;return b=b||{},b.hashType=b.hashType||c.HASH_TYPE,Promise.resolve().then(function(){return c.stringToBuffer(a)}).then(function(a){return window.crypto.subtle.digest(b.hashType,a)}).then(function(a){return c.bufferToHex(a)})},encrypt:function(a,b,c){if(!b)throw new Error("text required");if(!a)throw new Error("password required");var d=this,e=void 0,f=void 0,g=void 0;return c=c||{},c.rounds=c.rounds||d.ROUNDS,c.encoding=c.encoding||d.ENCODING,c.hashType=c.hashType||d.HASH_TYPE,c.algorithm=c.algorithm||d.ALGORITHM,c.hashBytes=c.hashBytes||d.HASH_BYTES,c.saltBytes=c.saltBytes||d.SALT_BYTES,c.vectorBytes=c.vectorBytes||d.VECTOR_BYTES,Promise.resolve().then(function(){return Promise.all([d.stringToBuffer(a),d.randomBytes(d.SALT_BYTES),d.randomBytes(d.VECTOR_BYTES)])}).then(function(a){e=a[1],f=a[2],g=a[0]}).then(function(){return Promise.all([d.stringToBuffer(b),d.pbkdf2(g,e,c.rounds,c.hashType,c.algorithm)])}).then(function(a){var b=a[0],c=a[1];return window.crypto.subtle.encrypt({name:d.ALGORITHM,iv:f},c,b)}).then(function(a){return Promise.all([d.bufferToHex(a),d.bufferToHex(f),d.bufferToHex(e)]).then(function(a){return a.join(":")})})},decrypt:function(a,b,c){if(!a)throw new Error("password required");if(!b)throw new Error("encrypted required");var d=this,e=b.split(":"),f=e[0],g=e[1],h=e[2],i=void 0,j=void 0,k=void 0,l=void 0;return c=c||{},c.rounds=c.rounds||d.ROUNDS,c.encoding=c.encoding||d.ENCODING,c.hashType=c.hashType||d.HASH_TYPE,c.algorithm=c.algorithm||d.ALGORITHM,c.hashBytes=c.hashBytes||d.HASH_BYTES,Promise.all([d.hexToBuffer(f),d.hexToBuffer(g),d.hexToBuffer(h),d.stringToBuffer(a)]).then(function(a){j=a[0],k=a[1],l=a[2],i=a[3]}).then(function(){return d.pbkdf2(i,l,c.rounds,c.hashType,c.algorithm)}).then(function(a){return window.crypto.subtle.decrypt({name:d.ALGORITHM,iv:k},a,j)}).then(function(a){return d.bufferToString(a)})}}});